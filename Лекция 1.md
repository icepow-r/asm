Ниже — подробный, расширенный конспект «Практика 1. Программирование на ассемблере», собранный из транскрипта и записей с доски. Я сохранил формулировки преподавателя и добавил пояснения там, где это помогает быстрее понять материал.

# Подробный конспект (Практика 1)

## 1) Организационные моменты, контроль и зачёт

* **Посещаемость и активность.** Для допуска к дифференцированному зачёту требуется:
  **(а)** посетить не менее **80% лекций**, **(б)** активно работать на практиках. Нарушение любого из пунктов лишает допуска. Оценка по зачёту — по шкале **2–5**. Зачёт проходит **очно**, в компьютерном классе, в формате **теста**.  &#x20;
* **Технический мониторинг присутствия.** В учебном модуле фиксируется, кто находится на вкладке с трансляцией, всё событие логируется и может экспортироваться в Excel. Эти данные используются при принятии решения о допуске к зачёту.&#x20;

## 2) О курсе и стартовые допущения

* Дисциплина посвящена **программированию на ассемблере x86**. По опросам преподавателя, у большинства студентов **нет опыта** программирования на ассемблере — обучение будет вестись «с нуля».&#x20;

## 3) Языки высокого и низкого уровня: ключевое отличие

* **Высокоуровневые языки** (C, Python и др.) обеспечивают **переносимость** — одна и та же программа компилируется/запускается на разных архитектурах.
* **Ассемблер (низкий уровень)** жёстко **привязан к архитектуре** и её особенностям: свой набор машинных инструкций, регистров, нюансов работы процессора; кросс-платформенных «общих» мнемоник не существует. &#x20;

## 4) Два «Hello, world!» и разбор примера на ассемблере

* На доске показаны две версии:
  **(а)** на C (классический `printf`),
  **(б)** на ассемблере **под Unix-подобную ОС и архитектуру x86** (формат **ELF**). Этот пример *невозможно* собрать и запустить в Windows «как есть». &#x20;
* **Что делает ASM-пример (по шагам):**
  кладёт в стек размер и адрес строки `Hello World!\n`, подготавливает дескриптор `stdout` (=1), помещает в `EAX` номер системного вызова записи (`write`), вызывает ядро через `INT 0x80`, затем завершает программу через системный вызов выхода. &#x20;
* Итоговый ELF-файл у показанной версии — **\~376 байт** (пример компактности низкоуровневого кода).&#x20;

## 5) Где сегодня реально нужен ассемблер

1. **ОС и драйверы.** Для системного кода знание ассемблера базово необходимо. &#x20;
2. **Микроконтроллеры.** В сфере автоматизации часто выбирают **очень дешёвые МК**; у них крошечные ресурсы (оперативная память может измеряться **килобайтами**), поэтому код пишут на ассемблере — иначе не поместится/не поедет. &#x20;
3. **Информационная безопасность.** Реверс-инжиниринг, поиск уязвимостей и «недокументированных возможностей», анализ вредоносного ПО: дизассемблирование, понимание логики на уровне инструкций. &#x20;
4. **Ручная оптимизация ПО.** Там, где критичны производительность/размер, ручной ASM может давать заметные выигрыши. Преподаватель дал ссылку на заметку на Хабре как иллюстрацию эффективности оптимизаций.&#x20;

## 6) Инструменты, которыми будем пользоваться

* **Компилятор:** **FASM** — выбран для обучения. Причины: мощная система **макросов** и отсутствие необходимости в отдельном линкере — **FASM сразу выдаёт исполняемый файл** (в отличие от NASM, который требует компоновки объекта). После освоения FASM перейти на NASM несложно.&#x20;
* **Среда разработки:** **Fresh** — IDE, «заточенная» под FASM; даёт всё необходимое для практик. Историческая альтернатива **RadASM** сейчас не поддерживается, поэтому её не используем. &#x20;
* **Отладчик.** Нужен для пошагового выполнения и поиска **логических** ошибок (синтаксические ловит компилятор). Поддерживает обычные и **аппаратные** брейкпоинты на x86, включая сложные условия срабатывания. &#x20;
* **Дизассемблер и hex-редактор.**
  – *Hex-редактор* показывает/редактирует файл как **последовательность байтов** в шестнадцатеричном виде.
  – *Дизассемблер* переводит **машинный код** в инструкции ассемблера для изучения функциональности. Исторический «монополист» — **IDA Pro**; затем АНБ выложило в открытый доступ **Ghidra**, что стало большим событием: мощный, бесплатный инструмент реверса. &#x20;

## 7) Материалы и литература

* Русскоязычные учебники часто устарели (MS-DOS, реальный режим, TASM и пр.), читать тяжело и **практически неактуально**. Преподаватель отдельно критикует старый учебник Юрова (жёлтая обложка) за ориентацию на TASM/MS-DOS. &#x20;
* **Рекомендуется:** Виктор **Юров**, «**Ассемблер. Специальный справочник**» (синяя обложка) — выжимка из многотомных руководств Intel/AMD по x86, удобен как практический справочник. Книга выходила двумя изданиями; преподаватель советует **второе**.  &#x20;
* **Официальные мануалы Intel/AMD** огромны (тысячи страниц) и годятся как первоисточники, но мало пригодны для «листательного» чтения.&#x20;
* В раздаточных/форумных материалах преподавателя есть ссылки на полезные источники; прямых ссылок на пиратские копии книг **не даёт**. &#x20;

## 8) Домашние действия к следующим занятиям

* Подготовить рабочее окружение: **FASM + Fresh**, **отладчик**, **дизассемблер**, **hex-редактор**. Преподаватель пообещал выложить **подробное руководство с скриншотами** по установке/настройке, чтобы избежать ошибок. **VirtualBox не обязателен.** &#x20;

## 9) Ключевые термины, встречавшиеся на занятии (с мини-пояснениями)

* **ELF** — формат исполняемых файлов/библиотек в Unix-подобных ОС; именно под него приведён пример.&#x20;
* **Системный вызов (`INT 0x80`)** — переключение в ядро ОС для операций вроде `write`/`exit`; в примере так печатается строка и завершается процесс.&#x20;
* **Дескриптор файла** — целочисленный идентификатор потока/файла; `1` — стандартный вывод `stdout` (используется в примере).&#x20;
* **Регистр процессора** — «ячейка памяти внутри процессора», используется инструкциями напрямую (пример: `EAX`).&#x20;
* **Брейкпоинт (в т.ч. аппаратный)** — точка останова/условная остановка выполнения, аппаратная поддержка есть в x86.&#x20;
* **Дизассемблер / hex-редактор** — инструменты анализа и правки на уровне байтов/инструкций (см. раздел 6).&#x20;

## 10) Что запомнить «в одном экране»

* Ассемблер **не переносим**, но **незаменим** там, где критичны контроль над железом, размер и скорость (ОС/драйверы, МК, ИБ, оптимизация).  &#x20;
* На практике будем использовать **FASM + Fresh**, отладчик, дизассемблер (**Ghidra**) и **hex-редактор**.  &#x20;
* Для допуска: **≥80% лекций** + **активность на практиках**; зачёт — **очный тест**. &#x20;
